#include "ObservationQueue.hpp"

#include <algorithm>
#include <stdexcept>

/************************************************************************************************************************
 * @brief   观测队列类构造函数
 * @param   history_len     历史帧数（网络所需历史长度）
 * @param   obs_dim         单帧观测维度（展平后一帧的元素个数）
 * @note    内部采用环形缓冲，将 H x D 存储在一维数组中，避免频繁分配；getFlattened 时按时间顺序拷贝。
 ***********************************************************************************************************************/
ObservationQueue::ObservationQueue(std::size_t history_len, std::size_t obs_dim)
: H_(history_len),
  D_(obs_dim),
  buf_(history_len * obs_dim, 0.0f),
  head_(0),
  filled_(0)
{
    if (H_ == 0 || D_ == 0)
    {
        throw std::invalid_argument("ObservationQueue: history_len and obs_dim must be > 0");
    }
}

/************************************************************************************************************************
 * @brief   推入一帧观测
 * @param   obs     输入观测向量（长度必须 == obs_dim）
 * @return  true    推入成功
 * @return  false   输入维度不匹配（不会修改队列）
 * @details 将 obs 写入到当前 head_ 指向的行（大小为 D_），随后 head_ 前移；filled_ 最多增长到 H_。
 ***********************************************************************************************************************/
bool ObservationQueue::push(const std::vector<float>& obs)
{
    if (obs.size() != D_)
    {
        return false;
    }

    // 写入目标行的起始下标（行主序：row * D_）
    const std::size_t row = head_;
    float* dst = buf_.data() + row * D_;
    std::copy(obs.begin(), obs.end(), dst);

    // 移动写指针
    head_ = (head_ + 1) % H_;
    if (filled_ < H_)
    {
        ++filled_;
    }
    return true;
}

/************************************************************************************************************************
 * @brief   清空队列（全部置零）
 * @details 将缓冲区清零，写指针复位，计数清零。调用后 ready() 将返回 false。
 ***********************************************************************************************************************/
void ObservationQueue::reset()
{
    std::fill(buf_.begin(), buf_.end(), 0.0f);
    head_ = 0;
    filled_ = 0;
}

/************************************************************************************************************************
 * @brief   队列是否已积满 history_len 帧
 ***********************************************************************************************************************/
bool ObservationQueue::ready() const
{
    return filled_ == H_;
}

/************************************************************************************************************************
 * @brief   当前已积累的帧数
 * @details 在“预热期”未填满前可用于判断是否需要跳过推理或使用占位数据。
 ***********************************************************************************************************************/
std::size_t ObservationQueue::size() const
{
    return filled_;
}

/************************************************************************************************************************
 * @brief   获取展平后的历史观测（从旧到新）
 * @param   out     输出一维向量，长度将被设置为 H_ * D_
 * @note    时间顺序定义为：最旧的帧在前，最新的帧在后。如果尚未填满，前 (H_-filled_) 段为构造时的零值。
 *          当 filled_ < H_ 时，buf_ 前部仍是零；为了契合固定形状需求，仍返回固定长度（H_*D_）。
 ***********************************************************************************************************************/
void ObservationQueue::getFlattened(std::vector<float>& out) const
{
    out.resize(H_ * D_);

    // 队列逻辑：最新写入位置是 head_ 的“前一行”；最旧帧是 (head_ % H_) 位置。
    // 我们从“最旧帧”开始拷贝，按时间顺序拼接 H_ 行。
    for (std::size_t i = 0; i < H_; ++i)
    {
        // old_idx：第 i 段对应的源行号（按最旧→最新）
        const std::size_t old_idx = (head_ + i) % H_;
        const float* src = buf_.data() + old_idx * D_;
        float* dst = out.data() + i * D_;
        std::copy(src, src + D_, dst);
    }
}

/************************************************************************************************************************
 * @brief   获取参数：历史长度
 ***********************************************************************************************************************/
std::size_t ObservationQueue::historyLen() const
{
    return H_;
}

/************************************************************************************************************************
 * @brief   获取参数：单帧维度
 ***********************************************************************************************************************/
std::size_t ObservationQueue::obsDim() const
{
    return D_;
}
